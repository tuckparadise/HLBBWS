/*
 * Infobip Client API Libraries OpenAPI Specification
 * OpenAPI specification containing public endpoints supported in client API libraries.
 *
 * Contact: support@infobip.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using System.Threading;
using System.Threading.Tasks;
using Infobip.Api.Client;
using ClientConfiguration = Infobip.Api.Client.Configuration;
using Infobip.Api.Client.Model;

namespace Infobip.Api.Client.Api
{
    /// <summary>
    ///     Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISendEmailApiSync : IApiAccessor
    {
        #region Synchronous Operations

        /// <summary>
        ///     Email delivery reports
        /// </summary>
        /// <remarks>
        ///     Get one-time delivery reports for all sent emails.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="bulkId">Bulk ID for which report is requested. (optional)</param>
        /// <param name="limit">Maximum number of reports. (optional)</param>
        /// <returns>EmailReportsResult</returns>
        EmailReportsResult GetEmailDeliveryReports(string messageId = default(string), string bulkId = default(string),
            int? limit = default(int?));

        /// <summary>
        ///     Email delivery reports
        /// </summary>
        /// <remarks>
        ///     Get one-time delivery reports for all sent emails.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="bulkId">Bulk ID for which report is requested. (optional)</param>
        /// <param name="limit">Maximum number of reports. (optional)</param>
        /// <returns>ApiResponse of EmailReportsResult</returns>
        ApiResponse<EmailReportsResult> GetEmailDeliveryReportsWithHttpInfo(string messageId = default(string),
            string bulkId = default(string), int? limit = default(int?));

        /// <summary>
        ///     Get email logs
        /// </summary>
        /// <remarks>
        ///     This method allows you to get email logs of sent Email messagesId for request. Email logs are available for the
        ///     last 48 hours!
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="from"> (optional, default to &quot;&quot;)</param>
        /// <param name="to"> (optional, default to &quot;&quot;)</param>
        /// <param name="bulkId"> (optional, default to &quot;&quot;)</param>
        /// <param name="generalStatus"> (optional, default to &quot;&quot;)</param>
        /// <param name="sentSince"> (optional)</param>
        /// <param name="sentUntil"> (optional)</param>
        /// <param name="limit"> (optional)</param>
        /// <returns>EmailLogResponse</returns>
        EmailLogResponse GetEmailLogs(List<string> messageId = default(List<string>), string from = default(string),
            string to = default(string), string bulkId = default(string), string generalStatus = default(string),
            DateTimeOffset? sentSince = default(DateTimeOffset?), DateTimeOffset? sentUntil = default(DateTimeOffset?),
            int? limit = default(int?));

        /// <summary>
        ///     Get email logs
        /// </summary>
        /// <remarks>
        ///     This method allows you to get email logs of sent Email messagesId for request. Email logs are available for the
        ///     last 48 hours!
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="from"> (optional, default to &quot;&quot;)</param>
        /// <param name="to"> (optional, default to &quot;&quot;)</param>
        /// <param name="bulkId"> (optional, default to &quot;&quot;)</param>
        /// <param name="generalStatus"> (optional, default to &quot;&quot;)</param>
        /// <param name="sentSince"> (optional)</param>
        /// <param name="sentUntil"> (optional)</param>
        /// <param name="limit"> (optional)</param>
        /// <returns>ApiResponse of EmailLogResponse</returns>
        ApiResponse<EmailLogResponse> GetEmailLogsWithHttpInfo(List<string> messageId = default(List<string>),
            string from = default(string), string to = default(string), string bulkId = default(string),
            string generalStatus = default(string), DateTimeOffset? sentSince = default(DateTimeOffset?),
            DateTimeOffset? sentUntil = default(DateTimeOffset?), int? limit = default(int?));

        /// <summary>
        ///     Send fully featured email
        /// </summary>
        /// <remarks>
        ///     Send an email or multiple emails to a recipient or multiple recipients with CC/BCC enabled.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">Email address with optional sender name.</param>
        /// <param name="to">Email address of the recipient.</param>
        /// <param name="subject">Message subject.</param>
        /// <param name="cc">CC recipient email address. (optional)</param>
        /// <param name="bcc">BCC recipient email address. (optional)</param>
        /// <param name="text">Body of message. (optional)</param>
        /// <param name="bulkId">
        ///     The ID uniquely identifies the sent Email request. This filter will enable you to query delivery
        ///     reports for all the messages using just one request. You will receive a bulkId in the response after sending an
        ///     Email request. If you don&#39;t set your own bulkId, unique ID will be generated by our system and returned in the
        ///     API response. (Optional Field) (optional)
        /// </param>
        /// <param name="messageId">The ID that uniquely identifies the message sent for a recipient. (Optional Field) (optional)</param>
        /// <param name="templateid">
        ///     Template identifier based on which the email message is generated. The template is created
        ///     over Infobip web interface. If templateId is present then html and text values are ignored.   NOTE : This field
        ///     supports value of broadcast templateId only. Content templateId is not supported. (optional)
        /// </param>
        /// <param name="attachment">File attachment (optional)</param>
        /// <param name="inlineImage">
        ///     Using an inline image, it is possible to insert the image file inside the HTML code of the
        ///     email by using cid:FILENAME instead of providing any external link to image. (optional)
        /// </param>
        /// <param name="HTML">
        ///     HTML body of the message. If HTML and text fields are present, text field will be ignored and HTML
        ///     will be delivered as message body. (optional)
        /// </param>
        /// <param name="replyto">Email address to which recipients of the email can reply. (optional)</param>
        /// <param name="defaultplaceholders">
        ///     Default placeholder values used for all recipients. The values are used to generate
        ///     the email message. (optional)
        /// </param>
        /// <param name="preserverecipients">
        ///     This parameter enables preserving To recipients for an email when value is true,
        ///     default value is false for this parameter. (optional)
        /// </param>
        /// <param name="trackingUrl">
        ///     The URL on your callback server on which the open and click notifications will be sent. If
        ///     you are passing this parameter then track&#x3D;true will be assigned, you don&#39;t need to pass track&#x3D;true
        ///     separately. See the section \\\&quot;Tracking Notifications\\\&quot; below for details. (optional)
        /// </param>
        /// <param name="trackclicks">This parameter enables or disables track click feature. (optional)</param>
        /// <param name="trackopens">This parameter enables or disables track open feature. (optional)</param>
        /// <param name="track">
        ///     Enable or disable open and click tracking.Default value is true. Passing true will only enable
        ///     tracking and the statistics would be visible in web interface alone. This can be explicitly overridden by
        ///     trackopens and trackclikcs. (optional)
        /// </param>
        /// <param name="callbackData">
        ///     Additional client data that will be sent on the notifyUrl. The maximum value is 4000
        ///     characters. (optional)
        /// </param>
        /// <param name="intermediateReport">
        ///     The real-time Intermediate delivery report that will be sent on your callback server.
        ///     (optional)
        /// </param>
        /// <param name="notifyUrl">The URL on your callback server on which the Delivery report will be sent. (optional)</param>
        /// <param name="notifyContentType">
        ///     Preferred Delivery report content type. Can be application/json or application/xml.
        ///     (optional)
        /// </param>
        /// <param name="sendAt">
        ///     To schedule message at a given time in future. Time provided should be in UTC in following format:
        ///     yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.  (optional)
        /// </param>
        /// <returns>EmailSendResponse</returns>
        EmailSendResponse SendEmail(string from, string to, string subject, string cc = default(string),
            string bcc = default(string), string text = default(string), string bulkId = default(string),
            string messageId = default(string), int? templateid = default(int?),
            System.IO.Stream attachment = default(System.IO.Stream),
            System.IO.Stream inlineImage = default(System.IO.Stream), string HTML = default(string),
            string replyto = default(string), string defaultplaceholders = default(string),
            bool? preserverecipients = default(bool?), string trackingUrl = default(string),
            bool? trackclicks = default(bool?), bool? trackopens = default(bool?), bool? track = default(bool?),
            string callbackData = default(string), bool? intermediateReport = default(bool?),
            string notifyUrl = default(string), string notifyContentType = default(string),
            DateTimeOffset? sendAt = default(DateTimeOffset?));

        /// <summary>
        ///     Send fully featured email
        /// </summary>
        /// <remarks>
        ///     Send an email or multiple emails to a recipient or multiple recipients with CC/BCC enabled.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">Email address with optional sender name.</param>
        /// <param name="to">Email address of the recipient.</param>
        /// <param name="subject">Message subject.</param>
        /// <param name="cc">CC recipient email address. (optional)</param>
        /// <param name="bcc">BCC recipient email address. (optional)</param>
        /// <param name="text">Body of message. (optional)</param>
        /// <param name="bulkId">
        ///     The ID uniquely identifies the sent Email request. This filter will enable you to query delivery
        ///     reports for all the messages using just one request. You will receive a bulkId in the response after sending an
        ///     Email request. If you don&#39;t set your own bulkId, unique ID will be generated by our system and returned in the
        ///     API response. (Optional Field) (optional)
        /// </param>
        /// <param name="messageId">The ID that uniquely identifies the message sent for a recipient. (Optional Field) (optional)</param>
        /// <param name="templateid">
        ///     Template identifier based on which the email message is generated. The template is created
        ///     over Infobip web interface. If templateId is present then html and text values are ignored.   NOTE : This field
        ///     supports value of broadcast templateId only. Content templateId is not supported. (optional)
        /// </param>
        /// <param name="attachment">File attachment (optional)</param>
        /// <param name="inlineImage">
        ///     Using an inline image, it is possible to insert the image file inside the HTML code of the
        ///     email by using cid:FILENAME instead of providing any external link to image. (optional)
        /// </param>
        /// <param name="HTML">
        ///     HTML body of the message. If HTML and text fields are present, text field will be ignored and HTML
        ///     will be delivered as message body. (optional)
        /// </param>
        /// <param name="replyto">Email address to which recipients of the email can reply. (optional)</param>
        /// <param name="defaultplaceholders">
        ///     Default placeholder values used for all recipients. The values are used to generate
        ///     the email message. (optional)
        /// </param>
        /// <param name="preserverecipients">
        ///     This parameter enables preserving To recipients for an email when value is true,
        ///     default value is false for this parameter. (optional)
        /// </param>
        /// <param name="trackingUrl">
        ///     The URL on your callback server on which the open and click notifications will be sent. If
        ///     you are passing this parameter then track&#x3D;true will be assigned, you don&#39;t need to pass track&#x3D;true
        ///     separately. See the section \\\&quot;Tracking Notifications\\\&quot; below for details. (optional)
        /// </param>
        /// <param name="trackclicks">This parameter enables or disables track click feature. (optional)</param>
        /// <param name="trackopens">This parameter enables or disables track open feature. (optional)</param>
        /// <param name="track">
        ///     Enable or disable open and click tracking.Default value is true. Passing true will only enable
        ///     tracking and the statistics would be visible in web interface alone. This can be explicitly overridden by
        ///     trackopens and trackclikcs. (optional)
        /// </param>
        /// <param name="callbackData">
        ///     Additional client data that will be sent on the notifyUrl. The maximum value is 4000
        ///     characters. (optional)
        /// </param>
        /// <param name="intermediateReport">
        ///     The real-time Intermediate delivery report that will be sent on your callback server.
        ///     (optional)
        /// </param>
        /// <param name="notifyUrl">The URL on your callback server on which the Delivery report will be sent. (optional)</param>
        /// <param name="notifyContentType">
        ///     Preferred Delivery report content type. Can be application/json or application/xml.
        ///     (optional)
        /// </param>
        /// <param name="sendAt">
        ///     To schedule message at a given time in future. Time provided should be in UTC in following format:
        ///     yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.  (optional)
        /// </param>
        /// <returns>ApiResponse of EmailSendResponse</returns>
        ApiResponse<EmailSendResponse> SendEmailWithHttpInfo(string from, string to, string subject,
            string cc = default(string), string bcc = default(string), string text = default(string),
            string bulkId = default(string), string messageId = default(string), int? templateid = default(int?),
            System.IO.Stream attachment = default(System.IO.Stream),
            System.IO.Stream inlineImage = default(System.IO.Stream), string HTML = default(string),
            string replyto = default(string), string defaultplaceholders = default(string),
            bool? preserverecipients = default(bool?), string trackingUrl = default(string),
            bool? trackclicks = default(bool?), bool? trackopens = default(bool?), bool? track = default(bool?),
            string callbackData = default(string), bool? intermediateReport = default(bool?),
            string notifyUrl = default(string), string notifyContentType = default(string),
            DateTimeOffset? sendAt = default(DateTimeOffset?));

        #endregion Synchronous Operations
    }

    /// <summary>
    ///     Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISendEmailApiAsync : IApiAccessor
    {
        #region Asynchronous Operations

        /// <summary>
        ///     Email delivery reports
        /// </summary>
        /// <remarks>
        ///     Get one-time delivery reports for all sent emails.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="bulkId">Bulk ID for which report is requested. (optional)</param>
        /// <param name="limit">Maximum number of reports. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailReportsResult</returns>
        Task<EmailReportsResult> GetEmailDeliveryReportsAsync(string messageId = default(string),
            string bulkId = default(string), int? limit = default(int?),
            CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        ///     Email delivery reports
        /// </summary>
        /// <remarks>
        ///     Get one-time delivery reports for all sent emails.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="bulkId">Bulk ID for which report is requested. (optional)</param>
        /// <param name="limit">Maximum number of reports. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailReportsResult)</returns>
        Task<ApiResponse<EmailReportsResult>> GetEmailDeliveryReportsWithHttpInfoAsync(
            string messageId = default(string), string bulkId = default(string), int? limit = default(int?),
            CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        ///     Get email logs
        /// </summary>
        /// <remarks>
        ///     This method allows you to get email logs of sent Email messagesId for request. Email logs are available for the
        ///     last 48 hours!
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="from"> (optional, default to &quot;&quot;)</param>
        /// <param name="to"> (optional, default to &quot;&quot;)</param>
        /// <param name="bulkId"> (optional, default to &quot;&quot;)</param>
        /// <param name="generalStatus"> (optional, default to &quot;&quot;)</param>
        /// <param name="sentSince"> (optional)</param>
        /// <param name="sentUntil"> (optional)</param>
        /// <param name="limit"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailLogResponse</returns>
        Task<EmailLogResponse> GetEmailLogsAsync(List<string> messageId = default(List<string>),
            string from = default(string), string to = default(string), string bulkId = default(string),
            string generalStatus = default(string), DateTimeOffset? sentSince = default(DateTimeOffset?),
            DateTimeOffset? sentUntil = default(DateTimeOffset?), int? limit = default(int?),
            CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        ///     Get email logs
        /// </summary>
        /// <remarks>
        ///     This method allows you to get email logs of sent Email messagesId for request. Email logs are available for the
        ///     last 48 hours!
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="from"> (optional, default to &quot;&quot;)</param>
        /// <param name="to"> (optional, default to &quot;&quot;)</param>
        /// <param name="bulkId"> (optional, default to &quot;&quot;)</param>
        /// <param name="generalStatus"> (optional, default to &quot;&quot;)</param>
        /// <param name="sentSince"> (optional)</param>
        /// <param name="sentUntil"> (optional)</param>
        /// <param name="limit"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailLogResponse)</returns>
        Task<ApiResponse<EmailLogResponse>> GetEmailLogsWithHttpInfoAsync(
            List<string> messageId = default(List<string>), string from = default(string), string to = default(string),
            string bulkId = default(string), string generalStatus = default(string),
            DateTimeOffset? sentSince = default(DateTimeOffset?), DateTimeOffset? sentUntil = default(DateTimeOffset?),
            int? limit = default(int?), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        ///     Send fully featured email
        /// </summary>
        /// <remarks>
        ///     Send an email or multiple emails to a recipient or multiple recipients with CC/BCC enabled.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">Email address with optional sender name.</param>
        /// <param name="to">Email address of the recipient.</param>
        /// <param name="subject">Message subject.</param>
        /// <param name="cc">CC recipient email address. (optional)</param>
        /// <param name="bcc">BCC recipient email address. (optional)</param>
        /// <param name="text">Body of message. (optional)</param>
        /// <param name="bulkId">
        ///     The ID uniquely identifies the sent Email request. This filter will enable you to query delivery
        ///     reports for all the messages using just one request. You will receive a bulkId in the response after sending an
        ///     Email request. If you don&#39;t set your own bulkId, unique ID will be generated by our system and returned in the
        ///     API response. (Optional Field) (optional)
        /// </param>
        /// <param name="messageId">The ID that uniquely identifies the message sent for a recipient. (Optional Field) (optional)</param>
        /// <param name="templateid">
        ///     Template identifier based on which the email message is generated. The template is created
        ///     over Infobip web interface. If templateId is present then html and text values are ignored.   NOTE : This field
        ///     supports value of broadcast templateId only. Content templateId is not supported. (optional)
        /// </param>
        /// <param name="attachment">File attachment (optional)</param>
        /// <param name="inlineImage">
        ///     Using an inline image, it is possible to insert the image file inside the HTML code of the
        ///     email by using cid:FILENAME instead of providing any external link to image. (optional)
        /// </param>
        /// <param name="HTML">
        ///     HTML body of the message. If HTML and text fields are present, text field will be ignored and HTML
        ///     will be delivered as message body. (optional)
        /// </param>
        /// <param name="replyto">Email address to which recipients of the email can reply. (optional)</param>
        /// <param name="defaultplaceholders">
        ///     Default placeholder values used for all recipients. The values are used to generate
        ///     the email message. (optional)
        /// </param>
        /// <param name="preserverecipients">
        ///     This parameter enables preserving To recipients for an email when value is true,
        ///     default value is false for this parameter. (optional)
        /// </param>
        /// <param name="trackingUrl">
        ///     The URL on your callback server on which the open and click notifications will be sent. If
        ///     you are passing this parameter then track&#x3D;true will be assigned, you don&#39;t need to pass track&#x3D;true
        ///     separately. See the section \\\&quot;Tracking Notifications\\\&quot; below for details. (optional)
        /// </param>
        /// <param name="trackclicks">This parameter enables or disables track click feature. (optional)</param>
        /// <param name="trackopens">This parameter enables or disables track open feature. (optional)</param>
        /// <param name="track">
        ///     Enable or disable open and click tracking.Default value is true. Passing true will only enable
        ///     tracking and the statistics would be visible in web interface alone. This can be explicitly overridden by
        ///     trackopens and trackclikcs. (optional)
        /// </param>
        /// <param name="callbackData">
        ///     Additional client data that will be sent on the notifyUrl. The maximum value is 4000
        ///     characters. (optional)
        /// </param>
        /// <param name="intermediateReport">
        ///     The real-time Intermediate delivery report that will be sent on your callback server.
        ///     (optional)
        /// </param>
        /// <param name="notifyUrl">The URL on your callback server on which the Delivery report will be sent. (optional)</param>
        /// <param name="notifyContentType">
        ///     Preferred Delivery report content type. Can be application/json or application/xml.
        ///     (optional)
        /// </param>
        /// <param name="sendAt">
        ///     To schedule message at a given time in future. Time provided should be in UTC in following format:
        ///     yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.  (optional)
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailSendResponse</returns>
        Task<EmailSendResponse> SendEmailAsync(string from, string to, string subject, string cc = default(string),
            string bcc = default(string), string text = default(string), string bulkId = default(string),
            string messageId = default(string), int? templateid = default(int?),
            System.IO.Stream attachment = default(System.IO.Stream),
            System.IO.Stream inlineImage = default(System.IO.Stream), string HTML = default(string),
            string replyto = default(string), string defaultplaceholders = default(string),
            bool? preserverecipients = default(bool?), string trackingUrl = default(string),
            bool? trackclicks = default(bool?), bool? trackopens = default(bool?), bool? track = default(bool?),
            string callbackData = default(string), bool? intermediateReport = default(bool?),
            string notifyUrl = default(string), string notifyContentType = default(string),
            DateTimeOffset? sendAt = default(DateTimeOffset?),
            CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        ///     Send fully featured email
        /// </summary>
        /// <remarks>
        ///     Send an email or multiple emails to a recipient or multiple recipients with CC/BCC enabled.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">Email address with optional sender name.</param>
        /// <param name="to">Email address of the recipient.</param>
        /// <param name="subject">Message subject.</param>
        /// <param name="cc">CC recipient email address. (optional)</param>
        /// <param name="bcc">BCC recipient email address. (optional)</param>
        /// <param name="text">Body of message. (optional)</param>
        /// <param name="bulkId">
        ///     The ID uniquely identifies the sent Email request. This filter will enable you to query delivery
        ///     reports for all the messages using just one request. You will receive a bulkId in the response after sending an
        ///     Email request. If you don&#39;t set your own bulkId, unique ID will be generated by our system and returned in the
        ///     API response. (Optional Field) (optional)
        /// </param>
        /// <param name="messageId">The ID that uniquely identifies the message sent for a recipient. (Optional Field) (optional)</param>
        /// <param name="templateid">
        ///     Template identifier based on which the email message is generated. The template is created
        ///     over Infobip web interface. If templateId is present then html and text values are ignored.   NOTE : This field
        ///     supports value of broadcast templateId only. Content templateId is not supported. (optional)
        /// </param>
        /// <param name="attachment">File attachment (optional)</param>
        /// <param name="inlineImage">
        ///     Using an inline image, it is possible to insert the image file inside the HTML code of the
        ///     email by using cid:FILENAME instead of providing any external link to image. (optional)
        /// </param>
        /// <param name="HTML">
        ///     HTML body of the message. If HTML and text fields are present, text field will be ignored and HTML
        ///     will be delivered as message body. (optional)
        /// </param>
        /// <param name="replyto">Email address to which recipients of the email can reply. (optional)</param>
        /// <param name="defaultplaceholders">
        ///     Default placeholder values used for all recipients. The values are used to generate
        ///     the email message. (optional)
        /// </param>
        /// <param name="preserverecipients">
        ///     This parameter enables preserving To recipients for an email when value is true,
        ///     default value is false for this parameter. (optional)
        /// </param>
        /// <param name="trackingUrl">
        ///     The URL on your callback server on which the open and click notifications will be sent. If
        ///     you are passing this parameter then track&#x3D;true will be assigned, you don&#39;t need to pass track&#x3D;true
        ///     separately. See the section \\\&quot;Tracking Notifications\\\&quot; below for details. (optional)
        /// </param>
        /// <param name="trackclicks">This parameter enables or disables track click feature. (optional)</param>
        /// <param name="trackopens">This parameter enables or disables track open feature. (optional)</param>
        /// <param name="track">
        ///     Enable or disable open and click tracking.Default value is true. Passing true will only enable
        ///     tracking and the statistics would be visible in web interface alone. This can be explicitly overridden by
        ///     trackopens and trackclikcs. (optional)
        /// </param>
        /// <param name="callbackData">
        ///     Additional client data that will be sent on the notifyUrl. The maximum value is 4000
        ///     characters. (optional)
        /// </param>
        /// <param name="intermediateReport">
        ///     The real-time Intermediate delivery report that will be sent on your callback server.
        ///     (optional)
        /// </param>
        /// <param name="notifyUrl">The URL on your callback server on which the Delivery report will be sent. (optional)</param>
        /// <param name="notifyContentType">
        ///     Preferred Delivery report content type. Can be application/json or application/xml.
        ///     (optional)
        /// </param>
        /// <param name="sendAt">
        ///     To schedule message at a given time in future. Time provided should be in UTC in following format:
        ///     yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.  (optional)
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailSendResponse)</returns>
        Task<ApiResponse<EmailSendResponse>> SendEmailWithHttpInfoAsync(string from, string to, string subject,
            string cc = default(string), string bcc = default(string), string text = default(string),
            string bulkId = default(string), string messageId = default(string), int? templateid = default(int?),
            System.IO.Stream attachment = default(System.IO.Stream),
            System.IO.Stream inlineImage = default(System.IO.Stream), string HTML = default(string),
            string replyto = default(string), string defaultplaceholders = default(string),
            bool? preserverecipients = default(bool?), string trackingUrl = default(string),
            bool? trackclicks = default(bool?), bool? trackopens = default(bool?), bool? track = default(bool?),
            string callbackData = default(string), bool? intermediateReport = default(bool?),
            string notifyUrl = default(string), string notifyContentType = default(string),
            DateTimeOffset? sendAt = default(DateTimeOffset?),
            CancellationToken cancellationToken = default(CancellationToken));

        #endregion Asynchronous Operations
    }

    /// <summary>
    ///     Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISendEmailApi : ISendEmailApiSync, ISendEmailApiAsync
    {
    }

    /// <summary>
    ///     Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class SendEmailApi : ISendEmailApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class.
        /// </summary>
        /// <returns></returns>
        public SendEmailApi() : this((string)null)
        {
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class.
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        public SendEmailApi(string basePath)
        {
            Configuration = ClientConfiguration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(Configuration.BasePath);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = ClientConfiguration.DefaultExceptionFactory;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class using Configuration object.
        /// </summary>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public SendEmailApi(Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));

            Configuration = ClientConfiguration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(Configuration.BasePath);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = ClientConfiguration.DefaultExceptionFactory;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        ///     Some configuration settings will not be applied without passing an HttpClientHandler.
        ///     The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public SendEmailApi(HttpClient client) : this(client, (string)null)
        {
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        ///     Some configuration settings will not be applied without passing an HttpClientHandler.
        ///     The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public SendEmailApi(HttpClient client, string basePath)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = ClientConfiguration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = ClientConfiguration.DefaultExceptionFactory;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        ///     Some configuration settings will not be applied without passing an HttpClientHandler.
        ///     The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public SendEmailApi(HttpClient client, Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = ClientConfiguration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = ClientConfiguration.DefaultExceptionFactory;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public SendEmailApi(HttpClient client, HttpClientHandler handler) : this(client, handler, (string)null)
        {
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An instance of HttpClientHandler that is used by HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        public SendEmailApi(HttpClient client, HttpClientHandler handler, string basePath)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));
            if (handler == null) throw new ArgumentNullException(nameof(handler));

            Configuration = ClientConfiguration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, handler, Configuration.BasePath);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = ClientConfiguration.DefaultExceptionFactory;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An instance of HttpClientHandler that is used by HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public SendEmailApi(HttpClient client, HttpClientHandler handler, Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));
            if (handler == null) throw new ArgumentNullException(nameof(handler));

            Configuration = ClientConfiguration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, handler, Configuration.BasePath);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = ClientConfiguration.DefaultExceptionFactory;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="SendEmailApi" /> class
        ///     using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public SendEmailApi(ISynchronousClient client, IAsynchronousClient asyncClient,
            IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = ClientConfiguration.DefaultExceptionFactory;
        }

        /// <summary>
        ///     Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        ///     The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        ///     The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        ///     Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        ///     Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        ///     Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        ///     Email delivery reports Get one-time delivery reports for all sent emails.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="bulkId">Bulk ID for which report is requested. (optional)</param>
        /// <param name="limit">Maximum number of reports. (optional)</param>
        /// <returns>EmailReportsResult</returns>
        public EmailReportsResult GetEmailDeliveryReports(string messageId = default(string),
            string bulkId = default(string), int? limit = default(int?))
        {
            var localVarResponse = GetEmailDeliveryReportsWithHttpInfo(messageId, bulkId, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        ///     Email delivery reports Get one-time delivery reports for all sent emails.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="bulkId">Bulk ID for which report is requested. (optional)</param>
        /// <param name="limit">Maximum number of reports. (optional)</param>
        /// <returns>ApiResponse of EmailReportsResult</returns>
        public ApiResponse<EmailReportsResult> GetEmailDeliveryReportsWithHttpInfo(string messageId = default(string),
            string bulkId = default(string), int? limit = default(int?))
        {
            var localVarRequestOptions = new RequestOptions();

            string[] contentTypes =
            {
            };

            // to determine the Accept header
            string[] accepts =
            {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (messageId != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "messageId", messageId));
            if (bulkId != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "bulkId", bulkId));
            if (limit != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));

            // authentication (APIKeyHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (Basic) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(Configuration.Username) || !string.IsNullOrEmpty(Configuration.Password))
                localVarRequestOptions.HeaderParameters.Add("Authorization",
                    "Basic " + ClientUtils.Base64Encode(Configuration.Username + ":" + Configuration.Password));
            // authentication (IBSSOTokenHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (OAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(Configuration.AccessToken))
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + Configuration.AccessToken);

            // make the HTTP request
            var localVarResponse =
                Client.Get<EmailReportsResult>("/email/1/reports", localVarRequestOptions, Configuration);

            Exception exception = ExceptionFactory?.Invoke("GetEmailDeliveryReports", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse;
        }

        /// <summary>
        ///     Email delivery reports Get one-time delivery reports for all sent emails.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="bulkId">Bulk ID for which report is requested. (optional)</param>
        /// <param name="limit">Maximum number of reports. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailReportsResult</returns>
        public async Task<EmailReportsResult> GetEmailDeliveryReportsAsync(string messageId = default(string),
            string bulkId = default(string), int? limit = default(int?),
            CancellationToken cancellationToken = default(CancellationToken))
        {
            ApiResponse<EmailReportsResult> localVarResponse =
                await GetEmailDeliveryReportsWithHttpInfoAsync(messageId, bulkId, limit, cancellationToken)
                    .ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///     Email delivery reports Get one-time delivery reports for all sent emails.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="bulkId">Bulk ID for which report is requested. (optional)</param>
        /// <param name="limit">Maximum number of reports. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailReportsResult)</returns>
        public async Task<ApiResponse<EmailReportsResult>> GetEmailDeliveryReportsWithHttpInfoAsync(
            string messageId = default(string), string bulkId = default(string), int? limit = default(int?),
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            string[] contentTypes =
            {
            };

            // to determine the Accept header
            string[] accepts =
            {
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (messageId != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "messageId", messageId));
            if (bulkId != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "bulkId", bulkId));
            if (limit != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));

            // authentication (APIKeyHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (Basic) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(Configuration.Username) || !string.IsNullOrEmpty(Configuration.Password))
                localVarRequestOptions.HeaderParameters.Add("Authorization",
                    "Basic " + ClientUtils.Base64Encode(Configuration.Username + ":" + Configuration.Password));
            // authentication (IBSSOTokenHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (OAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(Configuration.AccessToken))
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + Configuration.AccessToken);

            // make the HTTP request

            var localVarResponse = await AsynchronousClient
                .GetAsync<EmailReportsResult>("/email/1/reports", localVarRequestOptions, Configuration,
                    cancellationToken).ConfigureAwait(false);

            Exception exception = ExceptionFactory?.Invoke("GetEmailDeliveryReports", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse;
        }

        /// <summary>
        ///     Get email logs This method allows you to get email logs of sent Email messagesId for request. Email logs are
        ///     available for the last 48 hours!
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="from"> (optional, default to &quot;&quot;)</param>
        /// <param name="to"> (optional, default to &quot;&quot;)</param>
        /// <param name="bulkId"> (optional, default to &quot;&quot;)</param>
        /// <param name="generalStatus"> (optional, default to &quot;&quot;)</param>
        /// <param name="sentSince"> (optional)</param>
        /// <param name="sentUntil"> (optional)</param>
        /// <param name="limit"> (optional)</param>
        /// <returns>EmailLogResponse</returns>
        public EmailLogResponse GetEmailLogs(List<string> messageId = default(List<string>),
            string from = default(string), string to = default(string), string bulkId = default(string),
            string generalStatus = default(string), DateTimeOffset? sentSince = default(DateTimeOffset?),
            DateTimeOffset? sentUntil = default(DateTimeOffset?), int? limit = default(int?))
        {
            var localVarResponse =
                GetEmailLogsWithHttpInfo(messageId, from, to, bulkId, generalStatus, sentSince, sentUntil, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        ///     Get email logs This method allows you to get email logs of sent Email messagesId for request. Email logs are
        ///     available for the last 48 hours!
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="from"> (optional, default to &quot;&quot;)</param>
        /// <param name="to"> (optional, default to &quot;&quot;)</param>
        /// <param name="bulkId"> (optional, default to &quot;&quot;)</param>
        /// <param name="generalStatus"> (optional, default to &quot;&quot;)</param>
        /// <param name="sentSince"> (optional)</param>
        /// <param name="sentUntil"> (optional)</param>
        /// <param name="limit"> (optional)</param>
        /// <returns>ApiResponse of EmailLogResponse</returns>
        public ApiResponse<EmailLogResponse> GetEmailLogsWithHttpInfo(List<string> messageId = default(List<string>),
            string from = default(string), string to = default(string), string bulkId = default(string),
            string generalStatus = default(string), DateTimeOffset? sentSince = default(DateTimeOffset?),
            DateTimeOffset? sentUntil = default(DateTimeOffset?), int? limit = default(int?))
        {
            var localVarRequestOptions = new RequestOptions();

            string[] contentTypes =
            {
            };

            // to determine the Accept header
            string[] accepts =
            {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (messageId != null)
                localVarRequestOptions.QueryParameters.Add(
                    ClientUtils.ParameterToMultiMap("multi", "messageId", messageId));
            if (from != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            if (to != null) localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            if (bulkId != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "bulkId", bulkId));
            if (generalStatus != null)
                localVarRequestOptions.QueryParameters.Add(
                    ClientUtils.ParameterToMultiMap("", "generalStatus", generalStatus));
            if (sentSince != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sentSince", sentSince));
            if (sentUntil != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sentUntil", sentUntil));
            if (limit != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));

            // authentication (APIKeyHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (Basic) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(Configuration.Username) || !string.IsNullOrEmpty(Configuration.Password))
                localVarRequestOptions.HeaderParameters.Add("Authorization",
                    "Basic " + ClientUtils.Base64Encode(Configuration.Username + ":" + Configuration.Password));
            // authentication (IBSSOTokenHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (OAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(Configuration.AccessToken))
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + Configuration.AccessToken);

            // make the HTTP request
            var localVarResponse = Client.Get<EmailLogResponse>("/email/1/logs", localVarRequestOptions, Configuration);

            Exception exception = ExceptionFactory?.Invoke("GetEmailLogs", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse;
        }

        /// <summary>
        ///     Get email logs This method allows you to get email logs of sent Email messagesId for request. Email logs are
        ///     available for the last 48 hours!
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="from"> (optional, default to &quot;&quot;)</param>
        /// <param name="to"> (optional, default to &quot;&quot;)</param>
        /// <param name="bulkId"> (optional, default to &quot;&quot;)</param>
        /// <param name="generalStatus"> (optional, default to &quot;&quot;)</param>
        /// <param name="sentSince"> (optional)</param>
        /// <param name="sentUntil"> (optional)</param>
        /// <param name="limit"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailLogResponse</returns>
        public async Task<EmailLogResponse> GetEmailLogsAsync(List<string> messageId = default(List<string>),
            string from = default(string), string to = default(string), string bulkId = default(string),
            string generalStatus = default(string), DateTimeOffset? sentSince = default(DateTimeOffset?),
            DateTimeOffset? sentUntil = default(DateTimeOffset?), int? limit = default(int?),
            CancellationToken cancellationToken = default(CancellationToken))
        {
            ApiResponse<EmailLogResponse> localVarResponse = await GetEmailLogsWithHttpInfoAsync(messageId, from, to,
                bulkId, generalStatus, sentSince, sentUntil, limit, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///     Get email logs This method allows you to get email logs of sent Email messagesId for request. Email logs are
        ///     available for the last 48 hours!
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">The ID that uniquely identifies the sent email. (optional)</param>
        /// <param name="from"> (optional, default to &quot;&quot;)</param>
        /// <param name="to"> (optional, default to &quot;&quot;)</param>
        /// <param name="bulkId"> (optional, default to &quot;&quot;)</param>
        /// <param name="generalStatus"> (optional, default to &quot;&quot;)</param>
        /// <param name="sentSince"> (optional)</param>
        /// <param name="sentUntil"> (optional)</param>
        /// <param name="limit"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailLogResponse)</returns>
        public async Task<ApiResponse<EmailLogResponse>> GetEmailLogsWithHttpInfoAsync(
            List<string> messageId = default(List<string>), string from = default(string), string to = default(string),
            string bulkId = default(string), string generalStatus = default(string),
            DateTimeOffset? sentSince = default(DateTimeOffset?), DateTimeOffset? sentUntil = default(DateTimeOffset?),
            int? limit = default(int?), CancellationToken cancellationToken = default(CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            string[] contentTypes =
            {
            };

            // to determine the Accept header
            string[] accepts =
            {
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (messageId != null)
                localVarRequestOptions.QueryParameters.Add(
                    ClientUtils.ParameterToMultiMap("multi", "messageId", messageId));
            if (from != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            if (to != null) localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            if (bulkId != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "bulkId", bulkId));
            if (generalStatus != null)
                localVarRequestOptions.QueryParameters.Add(
                    ClientUtils.ParameterToMultiMap("", "generalStatus", generalStatus));
            if (sentSince != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sentSince", sentSince));
            if (sentUntil != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sentUntil", sentUntil));
            if (limit != null)
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));

            // authentication (APIKeyHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (Basic) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(Configuration.Username) || !string.IsNullOrEmpty(Configuration.Password))
                localVarRequestOptions.HeaderParameters.Add("Authorization",
                    "Basic " + ClientUtils.Base64Encode(Configuration.Username + ":" + Configuration.Password));
            // authentication (IBSSOTokenHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (OAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(Configuration.AccessToken))
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + Configuration.AccessToken);

            // make the HTTP request

            var localVarResponse = await AsynchronousClient
                .GetAsync<EmailLogResponse>("/email/1/logs", localVarRequestOptions, Configuration, cancellationToken)
                .ConfigureAwait(false);

            Exception exception = ExceptionFactory?.Invoke("GetEmailLogs", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse;
        }

        /// <summary>
        ///     Send fully featured email Send an email or multiple emails to a recipient or multiple recipients with CC/BCC
        ///     enabled.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">Email address with optional sender name.</param>
        /// <param name="to">Email address of the recipient.</param>
        /// <param name="subject">Message subject.</param>
        /// <param name="cc">CC recipient email address. (optional)</param>
        /// <param name="bcc">BCC recipient email address. (optional)</param>
        /// <param name="text">Body of message. (optional)</param>
        /// <param name="bulkId">
        ///     The ID uniquely identifies the sent Email request. This filter will enable you to query delivery
        ///     reports for all the messages using just one request. You will receive a bulkId in the response after sending an
        ///     Email request. If you don&#39;t set your own bulkId, unique ID will be generated by our system and returned in the
        ///     API response. (Optional Field) (optional)
        /// </param>
        /// <param name="messageId">The ID that uniquely identifies the message sent for a recipient. (Optional Field) (optional)</param>
        /// <param name="templateid">
        ///     Template identifier based on which the email message is generated. The template is created
        ///     over Infobip web interface. If templateId is present then html and text values are ignored.   NOTE : This field
        ///     supports value of broadcast templateId only. Content templateId is not supported. (optional)
        /// </param>
        /// <param name="attachment">File attachment (optional)</param>
        /// <param name="inlineImage">
        ///     Using an inline image, it is possible to insert the image file inside the HTML code of the
        ///     email by using cid:FILENAME instead of providing any external link to image. (optional)
        /// </param>
        /// <param name="HTML">
        ///     HTML body of the message. If HTML and text fields are present, text field will be ignored and HTML
        ///     will be delivered as message body. (optional)
        /// </param>
        /// <param name="replyto">Email address to which recipients of the email can reply. (optional)</param>
        /// <param name="defaultplaceholders">
        ///     Default placeholder values used for all recipients. The values are used to generate
        ///     the email message. (optional)
        /// </param>
        /// <param name="preserverecipients">
        ///     This parameter enables preserving To recipients for an email when value is true,
        ///     default value is false for this parameter. (optional)
        /// </param>
        /// <param name="trackingUrl">
        ///     The URL on your callback server on which the open and click notifications will be sent. If
        ///     you are passing this parameter then track&#x3D;true will be assigned, you don&#39;t need to pass track&#x3D;true
        ///     separately. See the section \\\&quot;Tracking Notifications\\\&quot; below for details. (optional)
        /// </param>
        /// <param name="trackclicks">This parameter enables or disables track click feature. (optional)</param>
        /// <param name="trackopens">This parameter enables or disables track open feature. (optional)</param>
        /// <param name="track">
        ///     Enable or disable open and click tracking.Default value is true. Passing true will only enable
        ///     tracking and the statistics would be visible in web interface alone. This can be explicitly overridden by
        ///     trackopens and trackclikcs. (optional)
        /// </param>
        /// <param name="callbackData">
        ///     Additional client data that will be sent on the notifyUrl. The maximum value is 4000
        ///     characters. (optional)
        /// </param>
        /// <param name="intermediateReport">
        ///     The real-time Intermediate delivery report that will be sent on your callback server.
        ///     (optional)
        /// </param>
        /// <param name="notifyUrl">The URL on your callback server on which the Delivery report will be sent. (optional)</param>
        /// <param name="notifyContentType">
        ///     Preferred Delivery report content type. Can be application/json or application/xml.
        ///     (optional)
        /// </param>
        /// <param name="sendAt">
        ///     To schedule message at a given time in future. Time provided should be in UTC in following format:
        ///     yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.  (optional)
        /// </param>
        /// <returns>EmailSendResponse</returns>
        public EmailSendResponse SendEmail(string from, string to, string subject, string cc = default(string),
            string bcc = default(string), string text = default(string), string bulkId = default(string),
            string messageId = default(string), int? templateid = default(int?),
            System.IO.Stream attachment = default(System.IO.Stream),
            System.IO.Stream inlineImage = default(System.IO.Stream), string HTML = default(string),
            string replyto = default(string), string defaultplaceholders = default(string),
            bool? preserverecipients = default(bool?), string trackingUrl = default(string),
            bool? trackclicks = default(bool?), bool? trackopens = default(bool?), bool? track = default(bool?),
            string callbackData = default(string), bool? intermediateReport = default(bool?),
            string notifyUrl = default(string), string notifyContentType = default(string),
            DateTimeOffset? sendAt = default(DateTimeOffset?))
        {
            var localVarResponse = SendEmailWithHttpInfo(from, to, subject, cc, bcc, text, bulkId, messageId,
                templateid, attachment, inlineImage, HTML, replyto, defaultplaceholders, preserverecipients,
                trackingUrl, trackclicks, trackopens, track, callbackData, intermediateReport, notifyUrl,
                notifyContentType, sendAt);
            return localVarResponse.Data;
        }

        /// <summary>
        ///     Send fully featured email Send an email or multiple emails to a recipient or multiple recipients with CC/BCC
        ///     enabled.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">Email address with optional sender name.</param>
        /// <param name="to">Email address of the recipient.</param>
        /// <param name="subject">Message subject.</param>
        /// <param name="cc">CC recipient email address. (optional)</param>
        /// <param name="bcc">BCC recipient email address. (optional)</param>
        /// <param name="text">Body of message. (optional)</param>
        /// <param name="bulkId">
        ///     The ID uniquely identifies the sent Email request. This filter will enable you to query delivery
        ///     reports for all the messages using just one request. You will receive a bulkId in the response after sending an
        ///     Email request. If you don&#39;t set your own bulkId, unique ID will be generated by our system and returned in the
        ///     API response. (Optional Field) (optional)
        /// </param>
        /// <param name="messageId">The ID that uniquely identifies the message sent for a recipient. (Optional Field) (optional)</param>
        /// <param name="templateid">
        ///     Template identifier based on which the email message is generated. The template is created
        ///     over Infobip web interface. If templateId is present then html and text values are ignored.   NOTE : This field
        ///     supports value of broadcast templateId only. Content templateId is not supported. (optional)
        /// </param>
        /// <param name="attachment">File attachment (optional)</param>
        /// <param name="inlineImage">
        ///     Using an inline image, it is possible to insert the image file inside the HTML code of the
        ///     email by using cid:FILENAME instead of providing any external link to image. (optional)
        /// </param>
        /// <param name="HTML">
        ///     HTML body of the message. If HTML and text fields are present, text field will be ignored and HTML
        ///     will be delivered as message body. (optional)
        /// </param>
        /// <param name="replyto">Email address to which recipients of the email can reply. (optional)</param>
        /// <param name="defaultplaceholders">
        ///     Default placeholder values used for all recipients. The values are used to generate
        ///     the email message. (optional)
        /// </param>
        /// <param name="preserverecipients">
        ///     This parameter enables preserving To recipients for an email when value is true,
        ///     default value is false for this parameter. (optional)
        /// </param>
        /// <param name="trackingUrl">
        ///     The URL on your callback server on which the open and click notifications will be sent. If
        ///     you are passing this parameter then track&#x3D;true will be assigned, you don&#39;t need to pass track&#x3D;true
        ///     separately. See the section \\\&quot;Tracking Notifications\\\&quot; below for details. (optional)
        /// </param>
        /// <param name="trackclicks">This parameter enables or disables track click feature. (optional)</param>
        /// <param name="trackopens">This parameter enables or disables track open feature. (optional)</param>
        /// <param name="track">
        ///     Enable or disable open and click tracking.Default value is true. Passing true will only enable
        ///     tracking and the statistics would be visible in web interface alone. This can be explicitly overridden by
        ///     trackopens and trackclikcs. (optional)
        /// </param>
        /// <param name="callbackData">
        ///     Additional client data that will be sent on the notifyUrl. The maximum value is 4000
        ///     characters. (optional)
        /// </param>
        /// <param name="intermediateReport">
        ///     The real-time Intermediate delivery report that will be sent on your callback server.
        ///     (optional)
        /// </param>
        /// <param name="notifyUrl">The URL on your callback server on which the Delivery report will be sent. (optional)</param>
        /// <param name="notifyContentType">
        ///     Preferred Delivery report content type. Can be application/json or application/xml.
        ///     (optional)
        /// </param>
        /// <param name="sendAt">
        ///     To schedule message at a given time in future. Time provided should be in UTC in following format:
        ///     yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.  (optional)
        /// </param>
        /// <returns>ApiResponse of EmailSendResponse</returns>
        public ApiResponse<EmailSendResponse> SendEmailWithHttpInfo(string from, string to, string subject,
            string cc = default(string), string bcc = default(string), string text = default(string),
            string bulkId = default(string), string messageId = default(string), int? templateid = default(int?),
            System.IO.Stream attachment = default(System.IO.Stream),
            System.IO.Stream inlineImage = default(System.IO.Stream), string HTML = default(string),
            string replyto = default(string), string defaultplaceholders = default(string),
            bool? preserverecipients = default(bool?), string trackingUrl = default(string),
            bool? trackclicks = default(bool?), bool? trackopens = default(bool?), bool? track = default(bool?),
            string callbackData = default(string), bool? intermediateReport = default(bool?),
            string notifyUrl = default(string), string notifyContentType = default(string),
            DateTimeOffset? sendAt = default(DateTimeOffset?))
        {
            // verify the required parameter 'from' is set
            if (from == null)
                throw new ApiException(400, "Missing required parameter 'from' when calling SendEmailApi->SendEmail");

            // verify the required parameter 'to' is set
            if (to == null)
                throw new ApiException(400, "Missing required parameter 'to' when calling SendEmailApi->SendEmail");

            // verify the required parameter 'subject' is set
            if (subject == null)
                throw new ApiException(400,
                    "Missing required parameter 'subject' when calling SendEmailApi->SendEmail");

            var localVarRequestOptions = new RequestOptions();

            string[] contentTypes =
            {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] accepts =
            {
                "application/json",
                "application/xml"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.FormParameters.Add("from", ClientUtils.ParameterToString(from)); // form parameter
            localVarRequestOptions.FormParameters.Add("to", ClientUtils.ParameterToString(to)); // form parameter
            if (cc != null)
                localVarRequestOptions.FormParameters.Add("cc", ClientUtils.ParameterToString(cc)); // form parameter
            if (bcc != null)
                localVarRequestOptions.FormParameters.Add("bcc", ClientUtils.ParameterToString(bcc)); // form parameter
            localVarRequestOptions.FormParameters.Add("subject",
                ClientUtils.ParameterToString(subject)); // form parameter
            if (text != null)
                localVarRequestOptions.FormParameters.Add("text",
                    ClientUtils.ParameterToString(text)); // form parameter
            if (bulkId != null)
                localVarRequestOptions.FormParameters.Add("bulkId",
                    ClientUtils.ParameterToString(bulkId)); // form parameter
            if (messageId != null)
                localVarRequestOptions.FormParameters.Add("messageId",
                    ClientUtils.ParameterToString(messageId)); // form parameter
            if (templateid != null)
                localVarRequestOptions.FormParameters.Add("templateid",
                    ClientUtils.ParameterToString(templateid)); // form parameter
            if (attachment != null) localVarRequestOptions.FileParameters.Add("attachment", attachment);
            if (inlineImage != null) localVarRequestOptions.FileParameters.Add("inlineImage", inlineImage);
            if (HTML != null)
                localVarRequestOptions.FormParameters.Add("HTML",
                    ClientUtils.ParameterToString(HTML)); // form parameter
            if (replyto != null)
                localVarRequestOptions.FormParameters.Add("replyto",
                    ClientUtils.ParameterToString(replyto)); // form parameter
            if (defaultplaceholders != null)
                localVarRequestOptions.FormParameters.Add("defaultplaceholders",
                    ClientUtils.ParameterToString(defaultplaceholders)); // form parameter
            if (preserverecipients != null)
                localVarRequestOptions.FormParameters.Add("preserverecipients",
                    ClientUtils.ParameterToString(preserverecipients)); // form parameter
            if (trackingUrl != null)
                localVarRequestOptions.FormParameters.Add("trackingUrl",
                    ClientUtils.ParameterToString(trackingUrl)); // form parameter
            if (trackclicks != null)
                localVarRequestOptions.FormParameters.Add("trackclicks",
                    ClientUtils.ParameterToString(trackclicks)); // form parameter
            if (trackopens != null)
                localVarRequestOptions.FormParameters.Add("trackopens",
                    ClientUtils.ParameterToString(trackopens)); // form parameter
            if (track != null)
                localVarRequestOptions.FormParameters.Add("track",
                    ClientUtils.ParameterToString(track)); // form parameter
            if (callbackData != null)
                localVarRequestOptions.FormParameters.Add("callbackData",
                    ClientUtils.ParameterToString(callbackData)); // form parameter
            if (intermediateReport != null)
                localVarRequestOptions.FormParameters.Add("intermediateReport",
                    ClientUtils.ParameterToString(intermediateReport)); // form parameter
            if (notifyUrl != null)
                localVarRequestOptions.FormParameters.Add("notifyUrl",
                    ClientUtils.ParameterToString(notifyUrl)); // form parameter
            if (notifyContentType != null)
                localVarRequestOptions.FormParameters.Add("notifyContentType",
                    ClientUtils.ParameterToString(notifyContentType)); // form parameter
            if (sendAt != null)
                localVarRequestOptions.FormParameters.Add("sendAt",
                    ClientUtils.ParameterToString(sendAt)); // form parameter

            // authentication (APIKeyHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (Basic) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(Configuration.Username) || !string.IsNullOrEmpty(Configuration.Password))
                localVarRequestOptions.HeaderParameters.Add("Authorization",
                    "Basic " + ClientUtils.Base64Encode(Configuration.Username + ":" + Configuration.Password));
            // authentication (IBSSOTokenHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (OAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(Configuration.AccessToken))
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + Configuration.AccessToken);

            // make the HTTP request
            var localVarResponse =
                Client.Post<EmailSendResponse>("/email/2/send", localVarRequestOptions, Configuration);

            Exception exception = ExceptionFactory?.Invoke("SendEmail", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse;
        }

        /// <summary>
        ///     Send fully featured email Send an email or multiple emails to a recipient or multiple recipients with CC/BCC
        ///     enabled.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">Email address with optional sender name.</param>
        /// <param name="to">Email address of the recipient.</param>
        /// <param name="subject">Message subject.</param>
        /// <param name="cc">CC recipient email address. (optional)</param>
        /// <param name="bcc">BCC recipient email address. (optional)</param>
        /// <param name="text">Body of message. (optional)</param>
        /// <param name="bulkId">
        ///     The ID uniquely identifies the sent Email request. This filter will enable you to query delivery
        ///     reports for all the messages using just one request. You will receive a bulkId in the response after sending an
        ///     Email request. If you don&#39;t set your own bulkId, unique ID will be generated by our system and returned in the
        ///     API response. (Optional Field) (optional)
        /// </param>
        /// <param name="messageId">The ID that uniquely identifies the message sent for a recipient. (Optional Field) (optional)</param>
        /// <param name="templateid">
        ///     Template identifier based on which the email message is generated. The template is created
        ///     over Infobip web interface. If templateId is present then html and text values are ignored.   NOTE : This field
        ///     supports value of broadcast templateId only. Content templateId is not supported. (optional)
        /// </param>
        /// <param name="attachment">File attachment (optional)</param>
        /// <param name="inlineImage">
        ///     Using an inline image, it is possible to insert the image file inside the HTML code of the
        ///     email by using cid:FILENAME instead of providing any external link to image. (optional)
        /// </param>
        /// <param name="HTML">
        ///     HTML body of the message. If HTML and text fields are present, text field will be ignored and HTML
        ///     will be delivered as message body. (optional)
        /// </param>
        /// <param name="replyto">Email address to which recipients of the email can reply. (optional)</param>
        /// <param name="defaultplaceholders">
        ///     Default placeholder values used for all recipients. The values are used to generate
        ///     the email message. (optional)
        /// </param>
        /// <param name="preserverecipients">
        ///     This parameter enables preserving To recipients for an email when value is true,
        ///     default value is false for this parameter. (optional)
        /// </param>
        /// <param name="trackingUrl">
        ///     The URL on your callback server on which the open and click notifications will be sent. If
        ///     you are passing this parameter then track&#x3D;true will be assigned, you don&#39;t need to pass track&#x3D;true
        ///     separately. See the section \\\&quot;Tracking Notifications\\\&quot; below for details. (optional)
        /// </param>
        /// <param name="trackclicks">This parameter enables or disables track click feature. (optional)</param>
        /// <param name="trackopens">This parameter enables or disables track open feature. (optional)</param>
        /// <param name="track">
        ///     Enable or disable open and click tracking.Default value is true. Passing true will only enable
        ///     tracking and the statistics would be visible in web interface alone. This can be explicitly overridden by
        ///     trackopens and trackclikcs. (optional)
        /// </param>
        /// <param name="callbackData">
        ///     Additional client data that will be sent on the notifyUrl. The maximum value is 4000
        ///     characters. (optional)
        /// </param>
        /// <param name="intermediateReport">
        ///     The real-time Intermediate delivery report that will be sent on your callback server.
        ///     (optional)
        /// </param>
        /// <param name="notifyUrl">The URL on your callback server on which the Delivery report will be sent. (optional)</param>
        /// <param name="notifyContentType">
        ///     Preferred Delivery report content type. Can be application/json or application/xml.
        ///     (optional)
        /// </param>
        /// <param name="sendAt">
        ///     To schedule message at a given time in future. Time provided should be in UTC in following format:
        ///     yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.  (optional)
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailSendResponse</returns>
        public async Task<EmailSendResponse> SendEmailAsync(string from, string to, string subject,
            string cc = default(string), string bcc = default(string), string text = default(string),
            string bulkId = default(string), string messageId = default(string), int? templateid = default(int?),
            System.IO.Stream attachment = default(System.IO.Stream),
            System.IO.Stream inlineImage = default(System.IO.Stream), string HTML = default(string),
            string replyto = default(string), string defaultplaceholders = default(string),
            bool? preserverecipients = default(bool?), string trackingUrl = default(string),
            bool? trackclicks = default(bool?), bool? trackopens = default(bool?), bool? track = default(bool?),
            string callbackData = default(string), bool? intermediateReport = default(bool?),
            string notifyUrl = default(string), string notifyContentType = default(string),
            DateTimeOffset? sendAt = default(DateTimeOffset?),
            CancellationToken cancellationToken = default(CancellationToken))
        {
            ApiResponse<EmailSendResponse> localVarResponse = await SendEmailWithHttpInfoAsync(from, to, subject, cc,
                bcc, text, bulkId, messageId, templateid, attachment, inlineImage, HTML, replyto, defaultplaceholders,
                preserverecipients, trackingUrl, trackclicks, trackopens, track, callbackData, intermediateReport,
                notifyUrl, notifyContentType, sendAt, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///     Send fully featured email Send an email or multiple emails to a recipient or multiple recipients with CC/BCC
        ///     enabled.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">Email address with optional sender name.</param>
        /// <param name="to">Email address of the recipient.</param>
        /// <param name="subject">Message subject.</param>
        /// <param name="cc">CC recipient email address. (optional)</param>
        /// <param name="bcc">BCC recipient email address. (optional)</param>
        /// <param name="text">Body of message. (optional)</param>
        /// <param name="bulkId">
        ///     The ID uniquely identifies the sent Email request. This filter will enable you to query delivery
        ///     reports for all the messages using just one request. You will receive a bulkId in the response after sending an
        ///     Email request. If you don&#39;t set your own bulkId, unique ID will be generated by our system and returned in the
        ///     API response. (Optional Field) (optional)
        /// </param>
        /// <param name="messageId">The ID that uniquely identifies the message sent for a recipient. (Optional Field) (optional)</param>
        /// <param name="templateid">
        ///     Template identifier based on which the email message is generated. The template is created
        ///     over Infobip web interface. If templateId is present then html and text values are ignored.   NOTE : This field
        ///     supports value of broadcast templateId only. Content templateId is not supported. (optional)
        /// </param>
        /// <param name="attachment">File attachment (optional)</param>
        /// <param name="inlineImage">
        ///     Using an inline image, it is possible to insert the image file inside the HTML code of the
        ///     email by using cid:FILENAME instead of providing any external link to image. (optional)
        /// </param>
        /// <param name="HTML">
        ///     HTML body of the message. If HTML and text fields are present, text field will be ignored and HTML
        ///     will be delivered as message body. (optional)
        /// </param>
        /// <param name="replyto">Email address to which recipients of the email can reply. (optional)</param>
        /// <param name="defaultplaceholders">
        ///     Default placeholder values used for all recipients. The values are used to generate
        ///     the email message. (optional)
        /// </param>
        /// <param name="preserverecipients">
        ///     This parameter enables preserving To recipients for an email when value is true,
        ///     default value is false for this parameter. (optional)
        /// </param>
        /// <param name="trackingUrl">
        ///     The URL on your callback server on which the open and click notifications will be sent. If
        ///     you are passing this parameter then track&#x3D;true will be assigned, you don&#39;t need to pass track&#x3D;true
        ///     separately. See the section \\\&quot;Tracking Notifications\\\&quot; below for details. (optional)
        /// </param>
        /// <param name="trackclicks">This parameter enables or disables track click feature. (optional)</param>
        /// <param name="trackopens">This parameter enables or disables track open feature. (optional)</param>
        /// <param name="track">
        ///     Enable or disable open and click tracking.Default value is true. Passing true will only enable
        ///     tracking and the statistics would be visible in web interface alone. This can be explicitly overridden by
        ///     trackopens and trackclikcs. (optional)
        /// </param>
        /// <param name="callbackData">
        ///     Additional client data that will be sent on the notifyUrl. The maximum value is 4000
        ///     characters. (optional)
        /// </param>
        /// <param name="intermediateReport">
        ///     The real-time Intermediate delivery report that will be sent on your callback server.
        ///     (optional)
        /// </param>
        /// <param name="notifyUrl">The URL on your callback server on which the Delivery report will be sent. (optional)</param>
        /// <param name="notifyContentType">
        ///     Preferred Delivery report content type. Can be application/json or application/xml.
        ///     (optional)
        /// </param>
        /// <param name="sendAt">
        ///     To schedule message at a given time in future. Time provided should be in UTC in following format:
        ///     yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.  (optional)
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailSendResponse)</returns>
        public async Task<ApiResponse<EmailSendResponse>> SendEmailWithHttpInfoAsync(string from, string to,
            string subject, string cc = default(string), string bcc = default(string), string text = default(string),
            string bulkId = default(string), string messageId = default(string), int? templateid = default(int?),
            System.IO.Stream attachment = default(System.IO.Stream),
            System.IO.Stream inlineImage = default(System.IO.Stream), string HTML = default(string),
            string replyto = default(string), string defaultplaceholders = default(string),
            bool? preserverecipients = default(bool?), string trackingUrl = default(string),
            bool? trackclicks = default(bool?), bool? trackopens = default(bool?), bool? track = default(bool?),
            string callbackData = default(string), bool? intermediateReport = default(bool?),
            string notifyUrl = default(string), string notifyContentType = default(string),
            DateTimeOffset? sendAt = default(DateTimeOffset?),
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'from' is set
            if (from == null)
                throw new ApiException(400, "Missing required parameter 'from' when calling SendEmailApi->SendEmail");

            // verify the required parameter 'to' is set
            if (to == null)
                throw new ApiException(400, "Missing required parameter 'to' when calling SendEmailApi->SendEmail");

            // verify the required parameter 'subject' is set
            if (subject == null)
                throw new ApiException(400,
                    "Missing required parameter 'subject' when calling SendEmailApi->SendEmail");


            var localVarRequestOptions = new RequestOptions();

            string[] contentTypes =
            {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] accepts =
            {
                "application/json",
                "application/xml"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.FormParameters.Add("from", ClientUtils.ParameterToString(from)); // form parameter
            localVarRequestOptions.FormParameters.Add("to", ClientUtils.ParameterToString(to)); // form parameter
            if (cc != null)
                localVarRequestOptions.FormParameters.Add("cc", ClientUtils.ParameterToString(cc)); // form parameter
            if (bcc != null)
                localVarRequestOptions.FormParameters.Add("bcc", ClientUtils.ParameterToString(bcc)); // form parameter
            localVarRequestOptions.FormParameters.Add("subject",
                ClientUtils.ParameterToString(subject)); // form parameter
            if (text != null)
                localVarRequestOptions.FormParameters.Add("text",
                    ClientUtils.ParameterToString(text)); // form parameter
            if (bulkId != null)
                localVarRequestOptions.FormParameters.Add("bulkId",
                    ClientUtils.ParameterToString(bulkId)); // form parameter
            if (messageId != null)
                localVarRequestOptions.FormParameters.Add("messageId",
                    ClientUtils.ParameterToString(messageId)); // form parameter
            if (templateid != null)
                localVarRequestOptions.FormParameters.Add("templateid",
                    ClientUtils.ParameterToString(templateid)); // form parameter
            if (attachment != null) localVarRequestOptions.FileParameters.Add("attachment", attachment);
            if (inlineImage != null) localVarRequestOptions.FileParameters.Add("inlineImage", inlineImage);
            if (HTML != null)
                localVarRequestOptions.FormParameters.Add("HTML",
                    ClientUtils.ParameterToString(HTML)); // form parameter
            if (replyto != null)
                localVarRequestOptions.FormParameters.Add("replyto",
                    ClientUtils.ParameterToString(replyto)); // form parameter
            if (defaultplaceholders != null)
                localVarRequestOptions.FormParameters.Add("defaultplaceholders",
                    ClientUtils.ParameterToString(defaultplaceholders)); // form parameter
            if (preserverecipients != null)
                localVarRequestOptions.FormParameters.Add("preserverecipients",
                    ClientUtils.ParameterToString(preserverecipients)); // form parameter
            if (trackingUrl != null)
                localVarRequestOptions.FormParameters.Add("trackingUrl",
                    ClientUtils.ParameterToString(trackingUrl)); // form parameter
            if (trackclicks != null)
                localVarRequestOptions.FormParameters.Add("trackclicks",
                    ClientUtils.ParameterToString(trackclicks)); // form parameter
            if (trackopens != null)
                localVarRequestOptions.FormParameters.Add("trackopens",
                    ClientUtils.ParameterToString(trackopens)); // form parameter
            if (track != null)
                localVarRequestOptions.FormParameters.Add("track",
                    ClientUtils.ParameterToString(track)); // form parameter
            if (callbackData != null)
                localVarRequestOptions.FormParameters.Add("callbackData",
                    ClientUtils.ParameterToString(callbackData)); // form parameter
            if (intermediateReport != null)
                localVarRequestOptions.FormParameters.Add("intermediateReport",
                    ClientUtils.ParameterToString(intermediateReport)); // form parameter
            if (notifyUrl != null)
                localVarRequestOptions.FormParameters.Add("notifyUrl",
                    ClientUtils.ParameterToString(notifyUrl)); // form parameter
            if (notifyContentType != null)
                localVarRequestOptions.FormParameters.Add("notifyContentType",
                    ClientUtils.ParameterToString(notifyContentType)); // form parameter
            if (sendAt != null)
                localVarRequestOptions.FormParameters.Add("sendAt",
                    ClientUtils.ParameterToString(sendAt)); // form parameter

            // authentication (APIKeyHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (Basic) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(Configuration.Username) || !string.IsNullOrEmpty(Configuration.Password))
                localVarRequestOptions.HeaderParameters.Add("Authorization",
                    "Basic " + ClientUtils.Base64Encode(Configuration.Username + ":" + Configuration.Password));
            // authentication (IBSSOTokenHeader) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
                if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
                    localVarRequestOptions.HeaderParameters.Add("Authorization",
                        Configuration.GetApiKeyWithPrefix("Authorization"));
            // authentication (OAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(Configuration.AccessToken))
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + Configuration.AccessToken);

            // make the HTTP request

            var localVarResponse = await AsynchronousClient
                .PostAsync<EmailSendResponse>("/email/2/send", localVarRequestOptions, Configuration, cancellationToken)
                .ConfigureAwait(false);

            Exception exception = ExceptionFactory?.Invoke("SendEmail", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse;
        }

        /// <summary>
        ///     Disposes resources if they were created by us
        /// </summary>
        public void Dispose()
        {
            ApiClient?.Dispose();
        }
    }
}